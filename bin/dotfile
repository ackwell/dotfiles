#!/usr/bin/env python3

import collections
import fnmatch
import getpass
import glob
import itertools
import json
import logging
import os
import platform
import re
import time
import uuid

def main():
	system = System()

	# Main linking output
	# TODO: Allow overwriting of output dir
	output_dir = os.path.expanduser('~')
	system.add_output('link', output_dir)

	# TODO: Allow overwriting of path.
	top_module = Module(os.path.expanduser('~/.dotfiles'), system)
	load_order = top_module.link()

	# TODO: Only do final linking if not a dry run
	system.execute(load_order)

class Module(object):
	def __init__(self, path, system):
		logging.debug('Initiating new module at path: %s', path)

		self.path = path
		self.system = system
		self.config = {}
		self.exists = True

		# Initial setup
		self._check_exists()
		self._load_config()
		self._set_name()

	def link(self, load_order=None):
		# If this module doesn't actually exist, cut out now.
		if not self.exists:
			return

		if load_order is None:
			load_order = []

		# Add any ouput mappings defined for this module
		remove = []
		for output in self.config.get('outputs', []):
			path = os.path.join(self.path, output)
			if not os.path.exists(path) or not os.path.isdir(path):
				logging.warning('%s is not a valid output directory', path)
				remove.append(output)
				continue

			self.system.add_output(output, path)

		# Done externally to avoid editing array that's being looped
		for output in remove:
			self.config['outputs'].remove(output)

		# Dependencies need to be loaded before the parent
		for dep in self._get_dependencies():
			path = os.path.join(self.path, dep) + '.module'
			module = Module(path, self.system)
			module.link(load_order)

		# Include this module
		load_order.append(self)

		# Remove our outputs now, to avoid the system trying to link files to themselves
		for output in self.config.get('outputs', []):
			self.system.remove_output(output)

		# Link all the current outputs
		for output_name in self.system.output_map.keys():
			self._link(output_name)

		return load_order

	def _link(self, output_name):
		link_dir = os.path.join(self.path, output_name)

		# Module doesn't have files to link, jump out
		if not os.path.exists(link_dir):
			return

		# Walk the link dir and ask for symlinks (they will be queued to allow for optimisation)
		for root, dirs, files in os.walk(link_dir):
			link_rel = root[len(link_dir):].lstrip('/')

			for file in files:
				self.system.queue_symlink(output_name, link_dir, os.path.join(link_rel, file), self.config['name'])

	def _check_exists(self):
		if not os.path.exists(self.path):
			logging.warning('Module not found, ignoring (looked for %s).', self.path)
			self.exists = False

	def _load_config(self):
		logging.debug('Loading config')

		try:
			conf_file = open(os.path.join(self.path, 'dotfile.json'))
		except FileNotFoundError:
			logging.debug('None found')
			return

		config = json.load(conf_file, object_pairs_hook=collections.OrderedDict)
		conf_file.close()

		self.config = config

	def _set_name(self):
		# If no name is set in config for the module, calculate one
		if not self.config.get('name'):
			basename = os.path.basename(self.path)
			if basename.endswith('.module'):
				basename = basename[:-7]
			self.config['name'] = basename

	def _get_dependencies(self):
		logging.debug('Calculating dependencies for %s', self.config['name'])
		whitelist = self.config.get('mode', 'blacklist') == 'whitelist'

		dep_list = [] if whitelist else self._get_modules_in_path()

		for pattern, modules in self.config.get('rules', {}).items():
			if not self._system_matches(pattern):
				continue

			for module, enable in modules.items():
				if enable and module not in dep_list:
					dep_list.append(module)
				elif not enable and module in dep_list:
					dep_list.remove(module)

		return dep_list

	def _get_modules_in_path(self):
		return [os.path.basename(mod)[:-7] for mod in glob.iglob(os.path.join(self.path, '*.module'))]

	def _system_matches(self, pattern):
		return re.search(pattern, self.system.id_string)

class System(object):
	def __init__(self):
		self.id_string = getpass.getuser() + '@' + platform.node() + ' ' + platform.system() + '-' + platform.release() + '-' + platform.machine()

		self.output_map = collections.defaultdict(str)
		self.backup_mappings = collections.defaultdict(list)
		self.link_queue = collections.defaultdict(
			lambda: collections.defaultdict(
				lambda: collections.defaultdict(
					lambda: {'files':[], 'dirs':[], 'path':''})))

		self.action_log = []

		self.persistent_state = ''

	def add_output(self, name, path):
		# Backup if already set
		if name in self.output_map:
			self.backup_mappings[name].append(self.output_map[name])

		self.output_map[name] = path

	def remove_output(self, name):
		# Remove the existing one
		try:
			del self.output_map[name]
		except KeyError:
			logging.warning('Tried to remove non-existant output map ' + name)

		# If there's a backup for this mapping, restore it
		if name in self.backup_mappings and len(self.backup_mappings[name]):
			self.output_map[name] = self.backup_mappings[name].pop()

	def queue_symlink(self, output_name, base_path, target, module_name=None):
		# If no module name is set, use a UUID to (try to) prevent clobbering
		if module_name is None:
			module_name = uuid.uuid4()

		if output_name not in self.output_map:
			logging.warning('Queue for unknown output name %s requested', output_name)
			return

		queue = self.link_queue[self.output_map[output_name]]

		# Loop over path segments, building queue's directory structure
		segments = self._split_path(target)
		previous = ''
		queue[previous][module_name]['path'] = os.path.join(base_path)
		for segment in segments[:-1]:
			if segment not in queue[previous][module_name]['dirs']:
				queue[previous][module_name]['dirs'].append(segment)
			previous = os.path.join(previous, segment)
			queue[previous][module_name]['path'] = os.path.join(base_path, previous)

		# Insert the absolute path to signify the entry is a link
		queue[previous][module_name]['files'].append(segments[-1])

	def execute(self, load_order):
		for output_dir in self.link_queue.keys():
			self._recurse_create_links('', output_dir, load_order)

	def _recurse_create_links(self, path, output_dir, load_order):
		queue = self.link_queue[output_dir][path]

		# If there's only one module vying for this dir, optimise by linking dir.
		# (Never link top level)
		if len(queue) == 1 and path != '':
			# Will only ever have the one module
			source = list(queue.values())[0]['path']
			target = os.path.join(output_dir, path)
			self._symlink(source, target, True)
			return

		# More than one module wants in, recurse/link each
		for module in load_order:
			module_name = module.config['name']
			if module_name not in queue:
				continue

			# Link files first
			data = queue[module_name]
			for file in data['files']:
				source = os.path.join(data['path'], file)
				target = os.path.join(output_dir, path, file)
				self._symlink(source, target)

			# Recurse into dirs
			for dir_ in data['dirs']:
				# TODO: create folder here!
				# TODO: Handle something already existing where folder would go
				self._recurse_create_links(os.path.join(path, dir_), output_dir, load_order)

	def _split_path(self, path):
		# Hat tips to https://stackoverflow.com/questions/4579908/cross-platform-splitting-of-path-in-python
		parts = []
		while True:
			head, tail = os.path.split(path)

			if head == path:
				if path:
					parts.append(path)
				break

			parts.append(tail)
			path = head

		parts.reverse()
		return parts

	def _symlink(self, source, target, target_is_directory=False):
		if not self._handle_exists(target):
			return

		self.action_log.append(('symlink', source, target, target_is_directory))
		logging.debug('Symlinking %s to %s (is%s a directory)', source, target, '' if target_is_directory else ' not')

		os.symlink(source, target, target_is_directory)

	def _handle_exists(self, target):
		# If the file doesn't exist already, OK to continue
		if not os.path.lexists(target):
			return True

		# File exists, decide how to handle
		state = self.persistent_state
		while len(state) != 1 or state.lower() not in 'sob':
			state = input(target + ' already exists. [s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all: ')

		# Persist the state if it was uppercase
		if state.isupper():
			state = state.lower()
			self.persistent_state = state

		# Skip - return false, handled by caller
		if state == 's':
			return False

		# Overwrite - remove old file
		if state == 'o':
			self._remove(target)

		# Backup
		elif state == 'b':
			self._backup(target)

		# Return True to signify it's OK to continue
		return True

	def _remove(self, target):
		self.action_log.append(('remove', target))
		logging.debug('Removing ' + target)

		if os.path.isdir(target) and not os.path.islink(target):
			for root, dirs, files in os.walk(target, topdown=False):
				for file in files:
					os.remove(os.path.join(root, file))
				for dir_ in dirs:
					os.remove(os.path.join(root, dir_))
		else:
			os.remove(target)

	def _backup(self, target):
		new_name = target + '.backup-' + str(round(time.time()))

		self.action_log.append(('rename', target, new_name))
		logging.debug('Backing up %s to %s', target, new_name)

		os.rename(target, new_name)


if __name__ == '__main__':
	main()
