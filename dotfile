#!/usr/bin/env python3

import collections
import fnmatch
import getpass
import glob
import json
import logging
import os
import platform
import re

def main():
	system = System()

	# TODO: Allow overriding of path.
	top_module = Module(os.path.expanduser('~/.dotfiles'), system)
	load_order = top_module.get_load_order()

	# TODO: Split this into seperate function and all that jazz
	for module in load_order:
		print(module.path)
		module.link()

class Module(object):
	def __init__(self, path, system):
		logging.debug('Initiating new module at path: %s', path)

		self.path = path
		self.system = system
		self.config = {}
		self.exists = True

		self._check_exists()
		self._load_config()
		self._set_name()

	def get_load_order(self, load_order=None):
		# If this module doesn't actually exist, cut out now.
		if not self.exists:
			return

		if load_order is None:
			load_order = []

		# Dependencies need to be loaded before the parent
		for dep in self._get_dependencies():
			path = os.path.join(self.path, dep) + '.module'
			module = Module(path, self.system)
			module.get_load_order(load_order)

		# Include this module
		load_order.append(self)

		return load_order

	def link(self):
		...

	def _check_exists(self):
		if not os.path.exists(self.path):
			logging.warning('Module not found, ignoring (looked for %s).', self.path)
			self.exists = False

	def _load_config(self):
		logging.debug('Loading config')

		try:
			conf_file = open(os.path.join(self.path, 'dotfile.json'))
		except FileNotFoundError:
			logging.debug('None found')
			return

		config = json.load(conf_file, object_pairs_hook=collections.OrderedDict)
		conf_file.close()

		self.config = config

	def _set_name(self):
		# If no name is set in config for the module, calculate one
		if not self.config.get('name'):
			basename = os.path.basename(self.path)
			if basename.endswith('.module'):
				basename = basename[:-7]
			self.config['name'] = basename

	def _get_dependencies(self):
		logging.debug('Calculating dependencies for %s', self.config['name'])
		whitelist = self.config.get('mode', 'blacklist') == 'whitelist'

		dep_list = [] if whitelist else self._get_modules_in_path()

		for pattern, modules in self.config.get('rules', {}).items():
			if not self._system_matches(pattern):
				continue

			for module, enable in modules.items():
				if enable and module not in dep_list:
					dep_list.append(module)
				elif not enable and module in dep_list:
					dep_list.remove(module)

		return dep_list

	def _get_modules_in_path(self):
		return [os.path.basename(mod)[:-7] for mod in glob.iglob(os.path.join(self.path, '*.module'))]

	def _system_matches(self, pattern):
		return re.search(pattern, self.system.id_string)

class System(object):
	def __init__(self):
		self.id_string = getpass.getuser() + '@' + platform.node() + ' ' + platform.system() + '-' + platform.release() + '-' + platform.machine()

if __name__ == '__main__':
	main()
